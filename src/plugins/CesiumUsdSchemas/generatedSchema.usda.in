#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class CesiumDataPrim "CesiumDataPrim" (
    doc = "Stores stage level data for Cesium for Omniverse/USD."
)
{
    bool cesium:debug:disableGeometryPool = 0 (
        displayName = "Disable Geometry Pool"
        doc = "Debug option that disables geometry pooling."
    )
    bool cesium:debug:disableGeoreferencing = 0 (
        displayName = "Disable Georeferencing"
        doc = "Debug option to disable georeferencing. Tiles will be rendered in EPSG:4978 (ECEF) coordinates where (0, 0, 0) is the center of the globe, the X axis points towards the prime meridian, the Y axis points towards the 90th meridian east, and the Z axis points towards the North Pole."
    )
    bool cesium:debug:disableMaterialPool = 0 (
        displayName = "Disable Material Pool"
        doc = "Debug option that disables material pooling."
    )
    bool cesium:debug:disableMaterials = 0 (
        displayName = "Disable Materials"
        doc = "Debug option that renders tilesets with materials disabled."
    )
    bool cesium:debug:disableTexturePool = 0 (
        displayName = "Disable Texture Pool"
        doc = "Debug option that disables texture pooling."
    )
    bool cesium:debug:disableTextures = 0 (
        displayName = "Disable Textures"
        doc = "Debug option that renders tilesets with textures disabled."
    )
    uint64 cesium:debug:geometryPoolInitialCapacity = 2048 (
        displayName = "Geometry Pool Initial Capacity"
        doc = "Debug option that controls the initial capacity of the geometry pool."
    )
    uint64 cesium:debug:materialPoolInitialCapacity = 2048 (
        displayName = "Material Pool Initial Capacity"
        doc = "Debug option that controls the initial capacity of the material pool."
    )
    bool cesium:debug:randomColors = 0 (
        displayName = "Random Colors"
        doc = "Debug option that renders tiles with random colors."
    )
    uint64 cesium:debug:texturePoolInitialCapacity = 2048 (
        displayName = "Texture Pool Initial Capacity"
        doc = "Debug option that controls the initial capacity of the texture pool."
    )
    string cesium:projectDefaultIonAccessToken = "" (
        displayName = "Project default ion Access Token"
        doc = "DEPRECATED: A string representing the token for accessing Cesium ion assets. Moved to CesiumIonServerPrim. Will be removed in a future version."
    )
    string cesium:projectDefaultIonAccessTokenId = "" (
        displayName = "Project default ion Access Token ID"
        doc = "DEPRECATED: A string representing the token ID for accessing Cesium ion assets. Moved to CesiumIonServerPrim. Will be removed in a future version."
    )
    rel cesium:selectedIonServer (
        displayName = "Selected ion Server context"
        doc = "The current ion Server prim used in the Cesium for Omniverse UI."
    )
}

class CesiumSessionPrim "CesiumSessionPrim" (
    doc = "Stores session layer state for Cesium for Omniverse/USD."
)
{
    matrix4d cesium:ecefToUsdTransform (
        displayName = "ECEF to USD Transform"
        doc = "The 4x4 transformation matrix (row major) from global ECEF coordinates to USD stage coordinates based on the georeference origin."
    )
}

class CesiumIonServerPrim "CesiumIonServerPrim" (
    doc = "Stores metadata related to Cesium ion server connections for tilesets."
)
{
    string cesium:displayName (
        displayName = "Display Name"
        doc = "The name to display for this server."
    )
    string cesium:ionServerApiUrl (
        displayName = "API URL"
        doc = "The base URL for the Cesium ion Server API."
    )
    int64 cesium:ionServerApplicationId (
        displayName = "OAuth Application ID"
        doc = "The application ID for the Cesium ion Server connection."
    )
    string cesium:ionServerUrl (
        displayName = "Server URL"
        doc = "The base URL for the Cesium ion Server."
    )
    string cesium:projectDefaultIonAccessToken = "" (
        displayName = "Default Cesium ion Access Token"
        doc = "A string representing the token for accessing Cesium ion assets."
    )
    string cesium:projectDefaultIonAccessTokenId = "" (
        displayName = "Default Cesium ion Access Token ID"
        doc = "A string representing the token ID for accessing Cesium ion assets."
    )
}

class CesiumGeoreferencePrim "CesiumGeoreferencePrim" (
    doc = "Stores Georeference data for Cesium for Omniverse. Every stage should have at least one of these."
)
{
    double cesium:georeferenceOrigin:height = 2250 (
        displayName = "Georeference Origin Height"
        doc = "The height of the origin in meters above the WGS84 ellipsoid. Do not confuse this with a geoid height or height above mean sea level, which can be tens of meters higher or lower depending on where in the world the origin is located."
    )
    double cesium:georeferenceOrigin:latitude = 39.736401 (
        displayName = "Georeference Original Latitude"
        doc = "The latitude of the origin in degrees, in the range [-90, 90]."
    )
    double cesium:georeferenceOrigin:longitude = -105.25737 (
        displayName = "Georeference Origin Longitude"
        doc = "The longitude of the origin in degrees, in the range [-180, 180]."
    )
}

class CesiumTilesetPrim "CesiumTilesetPrim" (
    doc = "A prim representing a tileset."
)
{
    float cesium:culledScreenSpaceError = 64 (
        displayName = "Culled Screen Space Error"
        doc = "The screen-space error to be enforced for tiles that are outside the frustum or hidden in fog. When Enable Frustum Culling and Enable Fog Culling are both true, tiles outside the view frustum or hidden in fog are effectively ignored, and so their level-of-detail doesn't matter. And in this scenario, this property is ignored. However, when either of those flags are false, these would-be-culled tiles continue to be processed, and the question arises of how to handle their level-of-detail. When this property is false, refinement terminates at these tiles, no matter what their current screen-space error. The tiles are available for physics, shadows, etc., but their level-of-detail may be very low. When set to true, these tiles are refined until they achieve the specified Culled Screen Space Error. This allows control over the minimum quality of these would-be-culled tiles."
    )
    bool cesium:enableFogCulling = 1 (
        displayName = "Enable Fog Culling"
        doc = "Whether to cull tiles that are occluded by fog. This does not refer to the atmospheric fog rendered by Unity, but to an internal representation of fog: Depending on the height of the camera above the ground, tiles that are far away (close to the horizon) will be culled when this flag is enabled. Note that this will always be disabled if Use Lod Transitions is set to true."
    )
    bool cesium:enableFrustumCulling = 1 (
        displayName = "Enable Frustum Culling"
        doc = "Whether to cull tiles that are outside the frustum. By default this is true, meaning that tiles that are not visible with the current camera configuration will be ignored. It can be set to false, so that these tiles are still considered for loading, refinement and rendering. This will cause more tiles to be loaded, but helps to avoid holes and provides a more consistent mesh, which may be helpful for physics and shadows. Note that this will always be disabled if Use Lod Transitions is set to true."
    )
    bool cesium:enforceCulledScreenSpaceError = 1 (
        displayName = "Enforce Culled Screen Space Error"
        doc = "Whether a specified screen-space error should be enforced for tiles that are outside the frustum or hidden in fog. When Enable Frustum Culling and Enable Fog Culling are both true, tiles outside the view frustum or hidden in fog are effectively ignored, and so their level-of-detail doesn't matter. And in this scenario, this property is ignored. However, when either of those flags are false, these would-be-culled tiles continue to be processed, and the question arises of how to handle their level-of-detail. When this property is false, refinement terminates at these tiles, no matter what their current screen-space error. The tiles are available for physics, shadows, etc., but their level-of-detail may be very low. When set to true, these tiles are refined until they achieve the specified Culled Screen Space Error. This allows control over the minimum quality of these would-be-culled tiles."
    )
    bool cesium:forbidHoles = 0 (
        displayName = "Forbid Holes"
        doc = "Whether to prevent refinement of a parent tile when a child isn't done loading. When this is set to true, the tileset will guarantee that the tileset will never be rendered with holes in place of tiles that are not yet loaded, even though the tile that is rendered instead may have low resolution. When false, overall loading will be faster, but newly-visible parts of the tileset may initially be blank."
    )
    rel cesium:georeferenceBinding (
        displayName = "Georeference Binding"
        doc = "Specifies which Cesium Georeference object to use for this tileset."
    )
    string cesium:ionAccessToken = "" (
        displayName = "ion Access Token"
        doc = "The access token to use to access the Cesium ion resource. Overrides the default token. Usually blank if using URL."
    )
    int64 cesium:ionAssetId = 0 (
        displayName = "ion Asset ID"
        doc = "The ID of the Cesium ion asset to use. Usually blank if using URL."
    )
    rel cesium:ionServerBinding (
        displayName = "Cesium ion Server Binding"
        doc = "Specifies which Cesium ion Server prim to use for this tileset."
    )
    uint cesium:loadingDescendantLimit = 20 (
        displayName = "Loading Descendant Limit"
        doc = "The number of loading descendants a tile should allow before deciding to render itself instead of waiting. Setting this to 0 will cause each level of detail to be loaded successively. This will increase the overall loading time, but cause additional detail to appear more gradually. Setting this to a high value like 1000 will decrease the overall time until the desired level of detail is achieved, but this high-detail representation will appear at once, as soon as it is loaded completely."
    )
    float cesium:mainThreadLoadingTimeLimit = 0 (
        displayName = "Main Thread Loading Time Limit"
        doc = "A soft limit on how long (in milliseconds) to spend on the main-thread part of tile loading each frame. A value of 0.0 indicates that all pending main-thread loads should be completed each tick."
    )
    uint64 cesium:maximumCachedBytes = 536870912 (
        displayName = "Maximum Cached Bytes"
        doc = "The maximum number of bytes that may be cached. Note that this value, even if 0, will never cause tiles that are needed for rendering to be unloaded. However, if the total number of loaded bytes is greater than this value, tiles will be unloaded until the total is under this number or until only required tiles remain, whichever comes first."
    )
    float cesium:maximumScreenSpaceError = 16 (
        displayName = "Maximum Screen Space Error"
        doc = "The maximum number of pixels of error when rendering this tileset. This is used to select an appropriate level-of-detail: A low value will cause many tiles with a high level of detail to be loaded, causing a finer visual representation of the tiles, but with a higher performance cost for loading and rendering. A higher value will cause a coarser visual representation, with lower performance requirements. When a tileset uses the older layer.json / quantized-mesh format rather than 3D Tiles, this value is effectively divided by 8.0. So the default value of 16.0 corresponds to the standard value for quantized-mesh terrain of 2.0."
    )
    uint cesium:maximumSimultaneousTileLoads = 20 (
        displayName = "Maximum Simultaneous Tile Loads"
        doc = "The maximum number of tiles that may be loaded at once. When new parts of the tileset become visible, the tasks to load the corresponding tiles are put into a queue. This value determines how many of these tasks are processed at the same time. A higher value may cause the tiles to be loaded and rendered more quickly, at the cost of a higher network and processing load."
    )
    bool cesium:preloadAncestors = 1 (
        displayName = "Preload Ancestors"
        doc = "Whether to preload ancestor tiles. Setting this to true optimizes the zoom-out experience and provides more detail in newly-exposed areas when panning. The down side is that it requires loading more tiles."
    )
    bool cesium:preloadSiblings = 1 (
        displayName = "Preload Siblings"
        doc = "Whether to preload sibling tiles. Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even if they are culled. Setting this to true may provide a better panning experience at the cost of loading more tiles."
    )
    bool cesium:showCreditsOnScreen = 0 (
        displayName = "Show Credits On Screen"
        doc = "Whether or not to show this tileset's credits on screen."
    )
    bool cesium:smoothNormals = 0 (
        displayName = "Smooth Normals"
        doc = "Generate smooth normals instead of flat normals when normals are missing."
    )
    uniform token cesium:sourceType = "ion" (
        allowedTokens = ["ion", "url"]
        displayName = "Source Type"
        doc = "Selects whether to use the Cesium ion Asset ID or the provided URL for this tileset."
    )
    bool cesium:suspendUpdate = 0 (
        displayName = "Suspend Update"
        doc = "Pauses level-of-detail and culling updates of this tileset."
    )
    string cesium:url = "" (
        displayName = "URL"
        doc = "The URL of this tileset's tileset.json file. Usually blank if this is an ion asset."
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "CesiumImageryPrim" (
    doc = "Abstract base class for prims that represent an imagery layer."
)
{
    float cesium:alpha = 1 (
        displayName = "Alpha"
        doc = "The alpha blending value, from 0.0 to 1.0, where 1.0 is fully opaque."
    )
    uniform token cesium:overlayRenderPipe = "overlay" (
        allowedTokens = ["overlay", "clip"]
        displayName = "Overlay Render Pipe"
        doc = "The Cesium default material will send the data down a given pipe with a different rendering treatment based on this selection."
    )
    bool cesium:showCreditsOnScreen = 0 (
        displayName = "Show Credits On Screen"
        doc = "Whether or not to show this imagery layer's credits on screen."
    )
}

class CesiumIonImageryPrim "CesiumIonImageryPrim" (
    doc = "Adds a prim for representing an Ion imagery layer. Should be a child of a tileset."
)
{
    float cesium:alpha = 1 (
        displayName = "Alpha"
        doc = "The alpha blending value, from 0.0 to 1.0, where 1.0 is fully opaque."
    )
    string cesium:ionAccessToken = "" (
        displayName = "ion Access Token"
        doc = "The access token to use to access the Cesium ion resource. Overrides the default token. Blank if using URL."
    )
    int64 cesium:ionAssetId = 0 (
        displayName = "Ion Asset ID"
        doc = "The ID of the Cesium ion asset to use."
    )
    rel cesium:ionServerBinding (
        displayName = "Cesium Ion Server Binding"
        doc = "Specifies which Cesium ion Server prim to use for this tileset."
    )
    uniform token cesium:overlayRenderPipe = "overlay" (
        allowedTokens = ["overlay", "clip"]
        displayName = "Overlay Render Pipe"
        doc = "The Cesium default material will send the data down a given pipe with a different rendering treatment based on this selection."
    )
    bool cesium:showCreditsOnScreen = 0 (
        displayName = "Show Credits On Screen"
        doc = "Whether or not to show this imagery layer's credits on screen."
    )
}

class CesiumPolygonImageryPrim "CesiumPolygonImageryPrim" (
    doc = "Adds a prim for representing a polygon imagery layer. Should be a child of a tileset."
)
{
    float cesium:alpha = 1 (
        displayName = "Alpha"
        doc = "The alpha blending value, from 0.0 to 1.0, where 1.0 is fully opaque."
    )
    rel cesium:cartographicPolygonBinding (
        displayName = "Cartographic Polygon Binding"
        doc = "Specifies which Cartraphic Polygons to use in the imagery layer"
    )
    uniform token cesium:overlayRenderPipe = "overlay" (
        allowedTokens = ["overlay", "clip"]
        displayName = "Overlay Render Pipe"
        doc = "The Cesium default material will send the data down a given pipe with a different rendering treatment based on this selection."
    )
    bool cesium:showCreditsOnScreen = 0 (
        displayName = "Show Credits On Screen"
        doc = "Whether or not to show this imagery layer's credits on screen."
    )
}

class CesiumCartographicPolygonPrim "CesiumCartographicPolygonPrim" (
    apiSchemas = ["CesiumGlobeAnchorSchemaAPI"]
    doc = "Adds a prim that represents a Cesium CartographicPolygon"
)
{
    vector3f[] accelerations (
        doc = """If provided, 'accelerations' should be used with
        velocities to compute positions between samples for the 'points'
        attribute rather than interpolating between neighboring 'points'
        samples. Acceleration is measured in position units per second-squared.
        To convert to position units per squared UsdTimeCode, divide by the
        square of UsdStage::GetTimeCodesPerSecond()."""
    )
    uniform token basis = "bezier" (
        allowedTokens = ["bezier", "bspline", "catmullRom"]
        doc = """The basis specifies the vstep and matrix used for cubic 
        interpolation.  \\note The 'hermite' and 'power' tokens have been
        removed. We've provided UsdGeomHermiteCurves
        as an alternative for the 'hermite' basis."""
    )
    int[] curveVertexCounts (
        doc = """Curves-derived primitives can represent multiple distinct,
        potentially disconnected curves.  The length of 'curveVertexCounts'
        gives the number of such curves, and each element describes the
        number of vertices in the corresponding curve"""
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    normal3f[] normals (
        doc = """Provide an object-space orientation for individual points, 
        which, depending on subclass, may define a surface, curve, or free 
        points.  Note that 'normals' should not be authored on any Mesh that
        is subdivided, since the subdivision algorithm will define its own
        normals. 'normals' is not a generic primvar, but the number of elements
        in this attribute will be determined by its 'interpolation'.  See
        . If 'normals' and 'primvars:normals'
        are both specified, the latter has precedence."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    point3f[] points (
        doc = """The primary geometry attribute for all PointBased
        primitives, describes points in (local) space."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    uniform token type = "cubic" (
        allowedTokens = ["linear", "cubic"]
        doc = """Linear curves interpolate linearly between two vertices.  
        Cubic curves use a basis matrix with four vertices to interpolate a segment."""
    )
    vector3f[] velocities (
        doc = """If provided, 'velocities' should be used by renderers to 

        compute positions between samples for the 'points' attribute, rather
        than interpolating between neighboring 'points' samples.  This is the
        only reasonable means of computing motion blur for topologically
        varying PointBased primitives.  It follows that the length of each
        'velocities' sample must match the length of the corresponding
        'points' sample.  Velocity is measured in position units per second,
        as per most simulation software. To convert to position units per
        UsdTimeCode, divide by UsdStage::GetTimeCodesPerSecond().
        
        See also ."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    float[] widths (
        doc = """Provides width specification for the curves, whose application
        will depend on whether the curve is oriented (normals are defined for
        it), in which case widths are \"ribbon width\", or unoriented, in which
        case widths are cylinder width.  'widths' is not a generic Primvar,
        but the number of elements in this attribute will be determined by
        its 'interpolation'.  See .  If 'widths'
        and 'primvars:widths' are both specified, the latter has precedence."""
    )
    uniform token wrap = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
        doc = """If wrap is set to periodic, the curve when rendered will 
        repeat the initial vertices (dependent on the vstep) to close the
        curve. If wrap is set to 'pinned', phantom points may be created
        to ensure that the curve interpolation starts at P[0] and ends at P[n-1].
        """
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "CesiumGlobeAnchorSchemaAPI" (
    doc = "Adds Globe Anchoring information to a Prim for use with Cesium for Omniverse."
)
{
    bool cesium:anchor:adjustOrientationForGlobeWhenMoving = 1 (
        displayName = "Adjust Orientation for Globe when Moving"
        doc = "Gets or sets whether to adjust the Prim's orientation based on globe curvature as the game object moves."
    )
    bool cesium:anchor:detectTransformChanges = 1 (
        displayName = "Detect Transform Changes"
        doc = "Gets or sets whether to automatically detect changes in the Prim's transform and update the precise globe coordinates accordingly."
    )
    double3 cesium:anchor:geographicCoordinates = (0, 0, 10) (
        displayName = "Geographic Coordinate (Latitude, Longitude, Height)"
        doc = "The position of the globally anchored prim as a Latitude, Longitude, Height coordinate."
    )
    rel cesium:anchor:georeferenceBinding (
        displayName = "Georeference Origin Binding"
        doc = "The Georeference Origin prim used for the globe anchor calculations."
    )
    double3 cesium:anchor:position = (0, 0, 0) (
        displayName = "Position (Earth-Centered, Earth-Fixed)"
        doc = "The actual position of the globally anchored prim in the ECEF coordinate system."
    )
    double3 cesium:anchor:rotation = (0, 0, 0) (
        displayName = "Rotation (East-Up-North)"
        doc = "The actual rotation of the globally anchored prim oriented to the ECEF coordinate system."
    )
    double3 cesium:anchor:scale = (1, 1, 1) (
        displayName = "Scale"
        doc = "The local scaling of the prim."
    )
}

