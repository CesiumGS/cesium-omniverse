mdl 1.8;

import ::anno::*;
import ::base::*;
import ::df::*;
import ::math::*;
import ::state::*;
import ::tex::*;
import ::scene::*;
import ::limits::*;


using ::gltf::pbr import *;

module [[
    anno::version( 1, 0, 0),
    anno::display_name("Cesium MDL functions")
]];

// For internal use only. See note in FabricMaterial.cpp
export gltf_texture_lookup_value cesium_texture_lookup(*) [[ anno::hidden() ]] = gltf_texture_lookup();
export material cesium_material(*) [[ anno::hidden() ]] = gltf_material();

::tex::wrap_mode convert_wrap_mode(gltf_wrapping_mode mode)
{
    if (mode == clamp_to_edge)
        return ::tex::wrap_clamp;
    if (mode == mirrored_repeat)
        return ::tex::wrap_mirrored_repeat;

    return ::tex::wrap_repeat;
}

float2 khr_texture_transform_apply(
    float2 coord,
    float2 offset,
    float rotation,
    float2 scale
)
{
    // MDL expects the texture coordinate origin at the bottom left (gltf at top left)
    // Assuming the renderer follows the MDL specification in which case the coordinates
    // have been flipped either while loading the glTF geometry or while setting up the state.

    // Undo the flipping for the transformation to get into the original glTF texture space.
    coord = float2(coord.x, 1.0f - coord.y);

    // first scale
    coord = coord * scale;
    // then rotate
    float cos_rotation = ::math::cos(rotation);
    float sin_rotation = ::math::sin(rotation);
    coord = float2(cos_rotation * coord.x + sin_rotation * coord.y, cos_rotation * coord.y - sin_rotation * coord.x);
    // then translate
    coord = coord + offset;

    // flip back
    coord = float2(coord.x, 1.0f - coord.y);
    return coord;
}

export gltf_texture_lookup_value cesium_texture_array_lookup(
    uniform texture_2d texture_0,
    uniform texture_2d texture_1,
    uniform texture_2d texture_2,
    uniform texture_2d texture_3,
    uniform texture_2d texture_4,
    uniform texture_2d texture_5,
    uniform texture_2d texture_6,
    uniform texture_2d texture_7,
    uniform texture_2d texture_8,
    uniform texture_2d texture_9,
    uniform texture_2d texture_10,
    uniform texture_2d texture_11,
    uniform texture_2d texture_12,
    uniform texture_2d texture_13,
    uniform texture_2d texture_14,
    uniform texture_2d texture_15,
)
{
    gltf_texture_lookup_value tex_ret;

    float3 tex_coord3 = state::texture_coordinate(0);
    float2 tex_coord = khr_texture_transform_apply(
        coord: float2(tex_coord3.x, tex_coord3.y),
        offset: float2(0.0f, 0.0),
        rotation: 0.0,
        scale: float2(1.0f, 1.0f));

    const int TEXTURES_LENGTH = 16;

    uniform texture_2d[TEXTURES_LENGTH] textures;
    textures[0] = texture_0;
    textures[1] = texture_1;
    textures[2] = texture_2;
    textures[3] = texture_3;
    textures[4] = texture_4;
    textures[5] = texture_5;
    textures[6] = texture_6;
    textures[7] = texture_7;
    textures[8] = texture_8;
    textures[9] = texture_9;
    textures[10] = texture_10;
    textures[11] = texture_11;
    textures[12] = texture_12;
    textures[13] = texture_13;
    textures[14] = texture_14;
    textures[15] = texture_15;

    int texture_index = ::scene::data_lookup_int("textureIndex");
    texture_index = texture_index % TEXTURES_LENGTH;

    for (int i = 0; i < TEXTURES_LENGTH; i++) {
        if (i == texture_index) {
            tex_ret.value = tex::lookup_float4(
                tex: textures[i],
                coord: tex_coord,
                wrap_u: ::tex::wrap_clamp,
                wrap_v: ::tex::wrap_clamp);
            tex_ret.valid = true;
            break;
        }
    }

    return tex_ret;
}
