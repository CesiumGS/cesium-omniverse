mdl 1.8;

import ::anno::*;
import ::state::*;
import ::tex::*;
import ::scene::*;

using ::gltf::pbr import *;

module [[
    anno::version( 1, 0, 0),
    anno::display_name("Cesium MDL functions")
]];

annotation annotation_not_connectable();

export enum up_axis_mode {
    Y,
    Z
};

float2 world_coordinate_2d(float2 min_world, float2 max_world, up_axis_mode up_axis)
{
    // Get the world pos of the pixel
    auto world_pos = state::transform_vector(state::coordinate_internal, state::coordinate_world, state::position());
    auto world_pos_horizontal = float2(world_pos.x, up_axis == Y ? world_pos.z : world_pos.y);

    // Return 0-1 UVs based on the min/max world coordinates provided
    return (world_pos_horizontal - min_world) / (max_world - min_world);
}

export float4 cesium_lookup_world_texture_float4(
    uniform texture_2d texture = texture_2d(),
    float2 min_world = float2(-5000.0, -5000.0),
    float2 max_world = float2(5000.0, 5000.0),
    up_axis_mode up_axis = Y)
[[
    anno::display_name("Cesium world-mapped texture lookup float4"),
    anno::description("Returns float4 from a texture mapped to world UV coordinates"),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]]
{
    return tex::lookup_float4(
        tex: texture,
        coord: world_coordinate_2d(min_world, max_world, up_axis),
        wrap_u: ::tex::wrap_clamp,
        wrap_v: ::tex::wrap_clamp);
}

export float3 cesium_lookup_world_texture_float3(
    uniform texture_2d texture = texture_2d(),
    float2 min_world = float2(-5000.0, -5000.0),
    float2 max_world = float2(5000.0, 5000.0),
    up_axis_mode up_axis = Y)
[[
    anno::display_name("Cesium world-mapped texture lookup float3"),
    anno::description("Returns float3 from a texture mapped to world UV coordinates"),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]]
{
    return tex::lookup_float3(
        tex: texture,
        coord: world_coordinate_2d(min_world, max_world, up_axis),
        wrap_u: ::tex::wrap_clamp,
        wrap_v: ::tex::wrap_clamp);
}

export color cesium_lookup_world_texture_color(
    uniform texture_2d texture = texture_2d(),
    float2 min_world = float2(-5000.0, -5000.0),
    float2 max_world = float2(5000.0, 5000.0),
    up_axis_mode up_axis = Y)
[[
    anno::display_name("Cesium world-mapped texture lookup color"),
    anno::description("Returns color from a texture mapped to world UV coordinates"),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]]
{
    return tex::lookup_color(
        tex: texture,
        coord: world_coordinate_2d(min_world, max_world, up_axis),
        wrap_u: ::tex::wrap_clamp,
        wrap_v: ::tex::wrap_clamp);
}

export float4 cesium_base_color_texture_float4(
    gltf_texture_lookup_value base_color_texture = gltf_texture_lookup_value()
    [[
        anno::hidden(),
        annotation_not_connectable()
    ]]
)
[[
    anno::display_name("Cesium base color texture lookup float4"),
    anno::description("Returns the base color texture as a float4. Returns [0, 0, 0, 0] if the base color texture does not exist."),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]]
{
    return base_color_texture.valid ? base_color_texture.value : float4(0.0);
}

export float4 cesium_imagery_layer_float4(
    gltf_texture_lookup_value imagery_layer = gltf_texture_lookup_value()
    [[
        anno::hidden(),
        annotation_not_connectable()
    ]],
    int imagery_layer_index = 0
    [[
        anno::unused()
    ]]
)
[[
    anno::display_name("Cesium imagery layer lookup float4"),
    anno::description("Returns the imagery layer at the given index as a float4. Returns [0, 0, 0, 0] if the imagery layer does not exist."),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]]
{
    return imagery_layer.valid ? imagery_layer.value : float4(0.0);
}

export material cesium_material(
    color base_color_factor = color(1.0)
    [[
        anno::display_name("Base Color Factor"),
        anno::description("The base color of the material.")
    ]],
    float metallic_factor = 0.0
    [[
        anno::hard_range(0.0, 1.0),
        anno::display_name("Metallic Factor"),
        anno::description("The metalness of the material. Select between dielectric (0.0) and metallic (1.0).")
    ]],

    float roughness_factor = 1.0
    [[
        anno::hard_range(0.0, 1.0),
        anno::display_name("Roughness Factor"),
        anno::description("The roughness of the material. Select between very glossy (0.0) and dull (1.0).")
    ]],
    color emissive_factor = color(0.0)
    [[
        anno::display_name("Emissive Factor"),
        anno::description("The emissive color of the material.")
    ]],
    uniform gltf_alpha_mode alpha_mode = opaque
    [[
        anno::display_name("Alpha Mode"),
        anno::description("Select how to interpret the alpha value.")
    ]],
    float base_alpha = 1.0
    [[
        anno::hard_range(0.0, 1.0),
        anno::display_name("Base Alpha"),
        anno::description("Select between transparent (0.0) and opaque (1.0)."),
        anno::enable_if("alpha_mode!=opaque")
    ]],
    uniform float alpha_cutoff  = 0.5
    [[
        anno::hard_range(0.0, 1.0),
        anno::display_name("Alpha Cutoff"),
        anno::description("Threshold to decide between fully transparent and fully opaque when alpha mode is 'mask'."),
        anno::enable_if("alpha_mode==mask")
    ]]
) [[
    anno::display_name("Cesium PBR material"),
    anno::description("Cesium metallic-roughness material based off glTF PBR model"),
    anno::author("Cesium GS Inc."),
    anno::in_group("Cesium")
]] = let {
    auto base_color = float3(base_color_factor);
    auto emissive = float3(emissive_factor);

    // We can't pass varyings (things not marked "uniform") to uniforms like base_color_factor, base_alpha, etc
    // To work around this, treat them as if they were texture values, which are varying.
    // If you look at gltf/pbr.mdl the math works out the same in either case.
    //
    // Previously our inputs were marked "uniform" but this caused a bunch of warnings like:
    //   uniform parameter 'base_color_factor' of material got varying attachment
    material base = gltf_material(
        base_color_texture: gltf_texture_lookup_value(true, float4(base_color.x, base_color.y, base_color.z, base_alpha)),
        metallic_roughness_texture: gltf_texture_lookup_value(true, float4(1.0, roughness_factor, metallic_factor, 1.0)),
        emissive_texture: gltf_texture_lookup_value(true, float4(emissive.x, emissive.y, emissive.z, 1.0)),
        alpha_mode: alpha_mode,
        alpha_cutoff: alpha_cutoff
    );

} in material(
    thin_walled: base.thin_walled,
    surface: base.surface,
    volume: base.volume,
    ior: base.ior,
    geometry: base.geometry
);

float4 alpha_blend(float4 src, float4 dst) {
    return src * float4(src.w, src.w, src.w, 1.0) + dst * (1.0 - src.w);
}

float4 compute_base_color(
    gltf_texture_lookup_value imagery_layers_texture,
    float4 tile_color,
    gltf_texture_lookup_value base_color_texture,
    color base_color_factor,
    float base_alpha) {

    auto base_color_factor_float3 = float3(base_color_factor);

    auto base_color = base_color_texture.valid ? base_color_texture.value : float4(1.0);
    base_color *= float4(base_color_factor_float3.x, base_color_factor_float3.y, base_color_factor_float3.z, base_alpha);
    base_color *= ::scene::data_lookup_float4("COLOR_0", float4(1.0));
    base_color = alpha_blend(imagery_layers_texture.value, base_color);
    base_color *= tile_color;

    return base_color;
}

export gltf_texture_lookup_value cesium_internal_texture_lookup(*) [[ anno::hidden() ]] = gltf_texture_lookup();

export gltf_texture_lookup_value cesium_internal_imagery_layer_lookup(
    uniform float alpha = 1.0,
    // gltf_texture_lookup inputs below
    uniform texture_2d texture = texture_2d(),
    uniform int tex_coord_index = 0,
    uniform float2 offset = float2(0.0, 0.0),
    uniform float rotation = 0.0,
    uniform float2 scale = float2(1.0, 1.0),
    uniform gltf_wrapping_mode wrap_s = repeat,
    uniform gltf_wrapping_mode wrap_t = repeat
) [[ anno::hidden() ]] {
    auto imagery_layer = gltf_texture_lookup(
        texture: texture,
        tex_coord_index: tex_coord_index,
        offset: offset,
        rotation: rotation,
        scale: scale,
        wrap_s: wrap_s,
        wrap_t: wrap_t
    );

    if (imagery_layer.valid) {
        imagery_layer.value.w *= alpha;
    }

    return imagery_layer;
}

export material cesium_internal_material(
    gltf_texture_lookup_value imagery_layers_texture = gltf_texture_lookup_value(true, float4(0.0)),
    uniform float4 tile_color = float4(1.0),
    // gltf_material inputs below
    gltf_texture_lookup_value base_color_texture = gltf_texture_lookup_value(),
    uniform color base_color_factor = color(1.0),
    uniform float metallic_factor = 1.0,
    uniform float roughness_factor = 1.0,
    uniform color emissive_factor = color(0.0),
    uniform gltf_alpha_mode alpha_mode = opaque,
    uniform float base_alpha = 1.0,
    uniform float alpha_cutoff  = 0.5
) [[ anno::hidden() ]] = let {
    auto base_color = compute_base_color(imagery_layers_texture, tile_color, base_color_texture, base_color_factor, base_alpha);
    material base = gltf_material(
        base_color_texture: gltf_texture_lookup_value(true, base_color),
        metallic_factor: metallic_factor,
        roughness_factor: roughness_factor,
        emissive_factor: emissive_factor,
        alpha_mode: alpha_mode,
        alpha_cutoff: alpha_cutoff
    );

} in material(
    thin_walled: base.thin_walled,
    surface: base.surface,
    volume: base.volume,
    ior: base.ior,
    geometry: base.geometry
);

export gltf_texture_lookup_value cesium_internal_imagery_layer_resolver(
    uniform int imagery_layers_count = 0,
    gltf_texture_lookup_value imagery_layer_0 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_1 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_2 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_3 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_4 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_5 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_6 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_7 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_8 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_9 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_10 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_11 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_12 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_13 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_14 = gltf_texture_lookup_value(),
    gltf_texture_lookup_value imagery_layer_15 = gltf_texture_lookup_value()
) [[ anno::hidden() ]] {
    // The array length should match MAX_IMAGERY_LAYERS_COUNT in Tokens.h
    gltf_texture_lookup_value[16] imagery_layers(
        imagery_layer_0,
        imagery_layer_1,
        imagery_layer_2,
        imagery_layer_3,
        imagery_layer_4,
        imagery_layer_5,
        imagery_layer_6,
        imagery_layer_7,
        imagery_layer_8,
        imagery_layer_9,
        imagery_layer_10,
        imagery_layer_11,
        imagery_layer_12,
        imagery_layer_13,
        imagery_layer_14,
        imagery_layer_15,
    );

    auto resolved_value = float4(0.0);

    for (int i = 0; i < imagery_layers_count; i++) {
        auto imagery_layer = imagery_layers[i];
        if (imagery_layer.valid) {
            resolved_value = alpha_blend(imagery_layer.value, resolved_value);
        }
    }

    return gltf_texture_lookup_value(true, resolved_value);
}
